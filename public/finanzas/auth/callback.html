<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Authenticating…</title>
    <meta name="robots" content="noindex" />
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 40px;
        color: #222;
      }
      .box {
        max-width: 500px;
        margin: auto;
        padding: 24px;
        border: 1px solid #ddd;
        border-radius: 12px;
      }
      code {
        background: #f6f6f6;
        padding: 2px 4px;
        border-radius: 4px;
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <div class="box">
      <h1>Signing you in…</h1>
      <p id="status">Processing identity token.</p>
      <p style="font-size: 12px">
        If you are not redirected automatically, choose:
        <a href="/finanzas/" id="finzLink">Finanzas</a> |
        <a href="/" id="pmoLink">PMO</a>
      </p>
      <script>
        (function () {
          // ✅ Enhanced logging for debugging
          console.log("[Callback] Starting authentication callback processing");
          console.log("[Callback] href:", window.location.href);
          console.log("[Callback] search:", window.location.search);
          console.log("[Callback] hash:", window.location.hash);
          
          /**
           * Parse URL hash/query parameters into a key-value map
           * Handles both # and ? prefixes, URL-encoded values, and parameters in any order
           */
          function parseParams(str) {
            if (!str) return {};
            const clean = str.startsWith("#") || str.startsWith("?") ? str.slice(1) : str;
            const params = {};
            if (clean) {
              clean.split("&").forEach(function(pair) {
                const parts = pair.split("=");
                if (parts.length === 2) {
                  try {
                    params[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
                  } catch (e) {
                    // Handle malformed encoding
                    params[parts[0]] = parts[1];
                  }
                }
              });
            }
            return params;
          }
          
          function showError(title, message, details) {
            console.error("[Callback] ERROR:", title, message);
            if (details) console.error("[Callback] Details:", details);
            document.getElementById("status").innerHTML = 
              '<strong style="color: #dc2626;">' + title + '</strong><br/>' + 
              '<span style="font-size: 14px;">' + message + '</span><br/>' +
              '<a href="/finanzas/" style="margin-top: 12px; display: inline-block; color: #2563eb;">Return to Finanzas</a>';
          }
          
          function showWarning(message) {
            console.warn("[Callback] WARNING:", message);
            document.getElementById("status").innerHTML = 
              '<span style="color: #f59e0b;">' + message + '</span><br/>' +
              '<a href="/finanzas/" style="margin-top: 12px; display: inline-block; color: #2563eb;">Return to Finanzas and sign in again</a>';
          }
          
          // Check for authorization code in URL query params (code flow)
          const queryParams = parseParams(window.location.search);
          const authCode = queryParams.code;

          if (authCode) {
            // Authorization code flow detected, but token exchange is not yet implemented
            console.warn(
              "[Callback] Authorization code received, but code → token exchange is not implemented yet. " +
                "Check response_type configuration in src/config/aws.ts"
            );
            showError(
              "Authorization Code Flow Not Supported",
              "The callback received an authorization code, but the application is configured for implicit flow.",
              "Please ensure response_type is set to 'token id_token' in aws.ts configuration."
            );
            return;
          }

          // Extract tokens from implicit flow hash (#id_token=...&access_token=...)
          const rawHash = window.location.hash || "";
          console.log("[Callback] Raw hash:", rawHash.substring(0, 150) + (rawHash.length > 150 ? "..." : ""));
          
          const hashParams = parseParams(rawHash);
          console.log("[Callback] Parsed hash parameters:", Object.keys(hashParams));
          
          // ✅ Case 1: OAuth error response (error + error_description in hash)
          if (hashParams.error) {
            const errorType = hashParams.error;
            const errorDesc = hashParams.error_description || "No description provided";
            
            console.error("[Callback] OAuth Error Received:");
            console.error("  Error:", errorType);
            console.error("  Description:", errorDesc);
            console.error("  Full hash:", rawHash);
            
            let userMessage = "OAuth authentication failed.";
            let technicalDetails = errorDesc;
            
            // Provide user-friendly messages for common errors
            if (errorType === "unauthorized_client") {
              userMessage = "Authentication configuration error.";
              technicalDetails = "The Cognito app client is not configured correctly. " +
                "Please verify that 'Implicit grant' is enabled and 'response_type=token id_token' is used.";
            } else if (errorType === "invalid_request") {
              userMessage = "Invalid authentication request.";
              technicalDetails = "The authentication request was malformed. " +
                "This may indicate a configuration issue with redirect URIs or scopes.";
            } else if (errorType === "access_denied") {
              userMessage = "Access denied.";
              technicalDetails = "You may have cancelled the login or do not have permission to access this application.";
            }
            
            showError(
              userMessage,
              technicalDetails,
              "Error code: " + errorType
            );
            return;
          }
          
          const idToken = hashParams.id_token;
          const accessToken = hashParams.access_token;
          const tokenType = hashParams.token_type;
          const expiresIn = hashParams.expires_in;
          
          console.log("[Callback] Token presence check:");
          console.log("  id_token:", !!idToken);
          console.log("  access_token:", !!accessToken);
          console.log("  token_type:", tokenType || "not provided");
          console.log("  expires_in:", expiresIn || "not provided");
          
          // ✅ Case 2: Valid tokens received
          if (idToken) {
            console.log("[Callback] ✅ id_token successfully extracted from hash");
            
            // Lightweight JWT payload decode
            function decodeJWT(t) {
              try {
                const p = t.split(".")[1];
                return JSON.parse(atob(p.replace(/-/g, "+").replace(/_/g, "/")));
              } catch (e) {
                console.error("[Callback] Failed to decode JWT:", e);
                return {};
              }
            }
            
            const claims = decodeJWT(idToken);
            console.log("[Callback] Token claims decoded successfully");
            console.log("[Callback] User:", claims.email || claims["cognito:username"] || "unknown");
            
            // ✅ Persist unified token (multiple keys for AuthProvider compatibility)
            // AuthProvider checks these keys in order: cv.jwt → finz_jwt → idToken → cognitoIdToken
            console.log("[Callback] Storing tokens in localStorage...");
            try {
              localStorage.setItem("cv.jwt", idToken);
              localStorage.setItem("finz_jwt", idToken);
              localStorage.setItem("idToken", idToken);
              localStorage.setItem("cognitoIdToken", idToken);
              if (accessToken) {
                localStorage.setItem("finz_access_token", accessToken);
                console.log("[Callback] ✅ Stored both id_token and access_token");
              } else {
                console.log("[Callback] ✅ Stored id_token (access_token not provided)");
              }
            } catch (e) {
              console.error("[Callback] Failed to store tokens in localStorage:", e);
              showError(
                "Storage Error",
                "Unable to save authentication tokens. This may be due to browser privacy settings or storage quotas.",
                e.message
              );
              return;
            }
            
            // Extract user groups from token claims
            const groupsRaw = claims["cognito:groups"] || claims["groups"] || [];
            const groups = Array.isArray(groupsRaw)
              ? groupsRaw
              : groupsRaw
                  .toString()
                  .split(",")
                  .map(function(s) { return s.trim(); })
                  .filter(Boolean);
            
            console.log("[Callback] User groups:", groups);
            
            // Determine user's module access based on groups
            const canSDT = groups.some(function(g) {
              return ["SDT", "FIN", "AUD", "sdmt", "fin", "aud"].includes(g.toUpperCase());
            });
            const canPMO = groups.some(function(g) {
              return ["PM", "PMO", "EXEC_RO", "VENDOR", "admin", "pmo"].includes(g.toUpperCase());
            });
            
            console.log("[Callback] Access rights - canSDT:", canSDT, "canPMO:", canPMO);
            
            // Preference resolution for dual-role users
            const pref = localStorage.getItem("cv.module");
            console.log("[Callback] Module preference:", pref || "none set");
            let target;
            
            if (canSDT && !canPMO) {
              target = "/finanzas/";
              console.log("[Callback] Routing: SDT-only user → /finanzas/");
            } else if (canPMO && !canSDT) {
              target = "/";
              console.log("[Callback] Routing: PMO-only user → /");
            } else if (canSDT && canPMO) {
              // Both roles - use preference or default to Finanzas
              if (pref === "pmo" && canPMO) {
                target = "/";
                console.log("[Callback] Routing: Dual-role user with PMO preference → /");
              } else if (pref === "finanzas" && canSDT) {
                target = "/finanzas/";
                console.log("[Callback] Routing: Dual-role user with Finanzas preference → /finanzas/");
              } else {
                // Default bias to Finanzas for dual-role users
                target = "/finanzas/";
                console.log("[Callback] Routing: Dual-role user (no preference) → /finanzas/ (default)");
              }
            } else {
              // No recognized groups - default to Finanzas
              target = "/finanzas/";
              console.log("[Callback] Routing: No recognized groups → /finanzas/ (fallback)");
            }
            
            console.log("[Callback] Final redirect target:", target);
            document.getElementById("status").textContent = "Redirecting to " + target + "…";
            
            // Use replace to avoid polluting browser history
            setTimeout(function() {
              console.log("[Callback] Executing redirect to:", target);
              window.location.replace(target);
            }, 50);
            
          } else {
            // ✅ Case 3: No tokens and no error (empty or incomplete hash)
            console.warn("[Callback] No id_token or error in callback URL");
            console.warn("[Callback] Hash parameters received:", Object.keys(hashParams));
            
            showWarning(
              "No authentication tokens found in the callback. " +
              "This may indicate an incomplete OAuth flow or a configuration issue."
            );
          }
        })();
        
        /*
         * ═══════════════════════════════════════════════════════════════════════
         * PRODUCTION VALIDATION STEPS
         * ═══════════════════════════════════════════════════════════════════════
         * 
         * Before deploying this file, validate locally:
         *   1. npm run lint
         *   2. npm run build:finanzas
         *   3. Check public/finanzas/auth/callback.html is copied to dist/
         * 
         * Manual production validation using Cognito test user:
         *   1. Navigate to: https://d7t9x3j66yd8k.cloudfront.net/finanzas/
         *   2. Click "Sign in with Cognito Hosted UI"
         *   3. Log in with test credentials (christian.valencia@ikusi.com)
         *   4. Watch URL bar during callback:
         *      - Should briefly hit /finanzas/auth/callback.html#id_token=...&access_token=...
         *      - Hash should contain id_token (no "unauthorized_client" errors)
         *      - Should NOT see infinite loops or "No id_token present" messages
         *   5. User should be redirected to /finanzas/ with dashboard visible
         *   6. Open DevTools → Application → Local Storage
         *      - Verify cv.jwt, finz_jwt, idToken, cognitoIdToken are present
         *      - Verify finz_access_token is present
         *   7. Refresh page at /finanzas/ and confirm session persists (no redirect to login)
         *   8. Check browser console for "[Callback]" logs showing successful flow
         * 
         * If you see errors like "unauthorized_client" or "invalid_request":
         *   - Verify Cognito app client has BOTH "Authorization code grant" AND "Implicit grant" enabled
         *   - Verify redirect URIs match exactly (including trailing slash)
         *   - Check that response_type in src/config/aws.ts is "token id_token"
         *   - Verify scopes include: openid, email, profile, aws.cognito.signin.user.admin
         * 
         * Environment variables required (see .env.example):
         *   - VITE_COGNITO_DOMAIN=us-east-2fyhltohiy.auth.us-east-2.amazoncognito.com
         *   - VITE_COGNITO_CLIENT_ID=dshos5iou44tuach7ta3ici5m
         *   - VITE_COGNITO_USER_POOL_ID=us-east-2_FyHLtOhiY
         *   - VITE_CLOUDFRONT_URL=https://d7t9x3j66yd8k.cloudfront.net
         */
      </script>
    </div>
  </body>
</html>
