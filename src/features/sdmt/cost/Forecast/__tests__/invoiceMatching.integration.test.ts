/**
 * Integration test for invoice matching and actual calculation
 * 
 * This test validates the complete invoice matching flow:
 * 1. Creates forecast rows with specific line items and months
 * 2. Creates invoices that should match these rows
 * 3. Validates that row.actual is correctly summed from matched invoices
 * 
 * This addresses the issue where Real (Actuals) show as $0 in the UI
 * despite invoices existing in the system.
 */

import { describe, it } from 'node:test';
import assert from 'node:assert';
import { canonicalizeRubroId } from '@/lib/rubros';

// Define ForecastRow type locally to avoid importing from React hook
interface ForecastRow {
  line_item_id: string;
  rubroId: string;
  description: string;
  month: number;
  planned: number;
  forecast: number;
  actual: number;
  variance: number;
  last_updated: string;
  updated_by: string;
  projectId?: string;
}

// Re-implement helper functions locally to avoid importing React hook
function normalizeInvoiceMonth(invoiceMonth: any, baselineStartMonth?: number): number {
  // If already a valid numeric month index, return it
  if (typeof invoiceMonth === 'number' && invoiceMonth >= 1 && invoiceMonth <= 60) {
    return invoiceMonth;
  }
  
  // If string, try various formats
  if (typeof invoiceMonth === 'string') {
    // Try YYYY-MM format first
    const yymmMatch = invoiceMonth.match(/^(\d{4})-(\d{2})$/);
    if (yymmMatch) {
      const monthNum = parseInt(yymmMatch[2], 10);
      return monthNum;
    }
    
    // Try full ISO date format (YYYY-MM-DD)
    const isoMatch = invoiceMonth.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (isoMatch) {
      const monthNum = parseInt(isoMatch[2], 10);
      return monthNum;
    }
    
    // Try M\d+ format (M1, M01, M11, M12, m11, etc. - with optional leading zero)
    const mMatch = invoiceMonth.match(/^m\s*0?(\d{1,2})$/i);
    if (mMatch) {
      const mm = parseInt(mMatch[1], 10);
      if (mm >= 1 && mm <= 60) return mm;
    }
    
    // Try ISO datetime (e.g., 2026-01-20T12:34:56Z or similar)
    if (invoiceMonth.includes('T') || /^\d{4}-\d{2}-\d{2}/.test(invoiceMonth)) {
      const isoDate = Date.parse(invoiceMonth);
      if (!isNaN(isoDate)) {
        const d = new Date(isoDate);
        const m = d.getUTCMonth() + 1;
        if (m >= 1 && m <= 12) return m;
      }
    }
    
    // Try parsing as plain number string
    const parsed = parseInt(invoiceMonth, 10);
    if (!isNaN(parsed) && parsed >= 1 && parsed <= 60) {
      return parsed;
    }
  }
  
  return 0; // Invalid month
}

function normalizeString(s: any): string {
  return (s || "").toString().trim().toLowerCase().replace(/\s+/g, " ");
}

function matchInvoiceToCell(inv: any, cell: ForecastRow): boolean {
  if (!inv) return false;

  // 1) projectId guard: both present → must match
  const invProject = inv.projectId || inv.project_id || inv.project;
  const cellProject = (cell as any).projectId || (cell as any).project_id || (cell as any).project;
  if (invProject && cellProject && String(invProject) !== String(cellProject)) {
    return false;
  }

  // 2) line_item_id: compare directly
  if (inv.line_item_id && cell.line_item_id) {
    if (inv.line_item_id === cell.line_item_id) {
      return true;
    }
  }

  // 3) canonical rubroId: use canonicalizeRubroId
  const invRubroId = inv.rubroId || inv.rubro_id;
  const cellRubroId = cell.rubroId || cell.line_item_id;
  
  if (invRubroId && cellRubroId) {
    const invCanonical = canonicalizeRubroId(invRubroId);
    const cellCanonical = canonicalizeRubroId(cellRubroId);
    if (invCanonical && cellCanonical && invCanonical === cellCanonical) {
      return true;
    }
  }

  // 4) normalized description: final fallback
  if (
    inv.description &&
    cell.description &&
    normalizeString(inv.description) === normalizeString(cell.description)
  ) {
    return true;
  }

  return false;
}

describe('Invoice Matching Integration Tests', () => {
  describe('Complete Invoice Matching Flow', () => {
    it('should match invoice to forecast row and sum actual amount', () => {
      // Step 1: Create a forecast row (as would be generated by computeForecastFromAllocations)
      const forecastRow: ForecastRow = {
        line_item_id: 'MOD-LEAD',
        rubroId: 'MOD-LEAD',
        description: 'Project Manager',
        month: 1,
        planned: 1000,
        forecast: 1100,
        actual: 0,
        variance: 0,
        last_updated: '2026-01-20T00:00:00Z',
        updated_by: 'system',
      };

      // Step 2: Create an invoice that should match this row
      const invoice = {
        project_id: 'TEST-PROJECT-001',
        line_item_id: 'MOD-LEAD',
        rubroId: 'MOD-LEAD',
        amount: 1050,
        month: '2026-01-20', // ISO date format
        status: 'posted',
        description: 'Project Manager',
      };

      // Step 3: Normalize invoice month (should return 1 for January)
      const normalizedMonth = normalizeInvoiceMonth(invoice.month);
      assert.strictEqual(normalizedMonth, 1, 'Invoice month should normalize to 1 (January)');

      // Step 4: Test matching logic
      const matches = matchInvoiceToCell(invoice, forecastRow);
      assert.strictEqual(matches, true, 'Invoice should match forecast row by line_item_id');

      // Step 5: Simulate the actual summing logic from useSDMTForecastData
      if (matches && normalizedMonth > 0 && forecastRow.month === normalizedMonth) {
        forecastRow.actual = (forecastRow.actual || 0) + invoice.amount;
      }

      // Step 6: Verify that actual was correctly updated
      assert.strictEqual(
        forecastRow.actual, 
        1050, 
        'Forecast row actual should be updated with invoice amount'
      );
    });

    it('should match multiple invoices to same row and sum amounts', () => {
      const forecastRow: ForecastRow = {
        line_item_id: 'MOD-DEV',
        rubroId: 'MOD-DEV',
        description: 'Software Developer',
        month: 2,
        planned: 2000,
        forecast: 2200,
        actual: 0,
        variance: 0,
        last_updated: '2026-01-20T00:00:00Z',
        updated_by: 'system',
      };

      const invoices = [
        {
          project_id: 'TEST-PROJECT-001',
          line_item_id: 'MOD-DEV',
          amount: 1000,
          month: '2026-02-15', // February ISO date
          status: 'paid',
        },
        {
          project_id: 'TEST-PROJECT-001',
          line_item_id: 'MOD-DEV',
          amount: 1200,
          month: '2026-02-28', // February ISO date
          status: 'approved',
        },
      ];

      // Process each invoice
      for (const invoice of invoices) {
        const normalizedMonth = normalizeInvoiceMonth(invoice.month);
        const matches = matchInvoiceToCell(invoice, forecastRow);
        
        if (matches && normalizedMonth > 0 && forecastRow.month === normalizedMonth) {
          forecastRow.actual = (forecastRow.actual || 0) + invoice.amount;
        }
      }

      // Verify total
      assert.strictEqual(
        forecastRow.actual,
        2200,
        'Multiple invoices should sum correctly'
      );
    });

    it('should not match invoice with different month', () => {
      const forecastRow: ForecastRow = {
        line_item_id: 'MOD-QA',
        rubroId: 'MOD-QA',
        description: 'QA Engineer',
        month: 3, // March
        planned: 1500,
        forecast: 1500,
        actual: 0,
        variance: 0,
        last_updated: '2026-01-20T00:00:00Z',
        updated_by: 'system',
      };

      const invoice = {
        project_id: 'TEST-PROJECT-001',
        line_item_id: 'MOD-QA',
        amount: 1600,
        month: '2026-04-15', // April (month 4), should not match month 3
        status: 'posted',
      };

      const normalizedMonth = normalizeInvoiceMonth(invoice.month);
      assert.strictEqual(normalizedMonth, 4, 'Invoice month should normalize to 4 (April)');

      const matches = matchInvoiceToCell(invoice, forecastRow);
      assert.strictEqual(matches, true, 'Line items should match');

      // Month guard should prevent summing
      if (matches && normalizedMonth > 0 && forecastRow.month === normalizedMonth) {
        forecastRow.actual = (forecastRow.actual || 0) + invoice.amount;
      }

      assert.strictEqual(
        forecastRow.actual,
        0,
        'Invoice with different month should not update actual'
      );
    });

    it('should match by canonical rubro ID even with different aliases', () => {
      const forecastRow: ForecastRow = {
        line_item_id: 'MOD-PM-PROJECT-MANAGER',
        rubroId: 'MOD-PM-PROJECT-MANAGER',
        description: 'Project Manager',
        month: 1,
        planned: 3000,
        forecast: 3000,
        actual: 0,
        variance: 0,
        last_updated: '2026-01-20T00:00:00Z',
        updated_by: 'system',
      };

      // Invoice uses different alias but same canonical ID
      const invoice = {
        project_id: 'TEST-PROJECT-001',
        line_item_id: 'MOD-LEAD', // Different alias
        rubroId: 'MOD-LEAD',
        amount: 3200,
        month: '2026-01-15',
        status: 'posted',
        description: 'Project Manager',
      };

      // Both should resolve to same canonical ID
      const forecastCanonical = canonicalizeRubroId('MOD-PM-PROJECT-MANAGER');
      const invoiceCanonical = canonicalizeRubroId('MOD-LEAD');
      
      // NOTE: This test reveals taxonomy gaps - if aliases don't map to same canonical ID,
      // it indicates the legacy map needs updating
      if (forecastCanonical !== invoiceCanonical) {
        console.warn(
          `[Test] Taxonomy gap detected: MOD-PM-PROJECT-MANAGER → ${forecastCanonical}, MOD-LEAD → ${invoiceCanonical}. ` +
          `Consider adding alias mapping to canonical taxonomy.`
        );
        // Still test that description matching works as a fallback
      }

      const normalizedMonth = normalizeInvoiceMonth(invoice.month);
      const matches = matchInvoiceToCell(invoice, forecastRow);

      if (matches && normalizedMonth > 0 && forecastRow.month === normalizedMonth) {
        forecastRow.actual = (forecastRow.actual || 0) + invoice.amount;
      }

      // Even if canonical IDs don't match, description matching should work
      assert.strictEqual(
        forecastRow.actual,
        3200,
        'Description matching should work as fallback when canonical IDs differ'
      );
    });

    it('should handle various invoice month formats', () => {
      const testCases = [
        { month: '2026-01-20', expected: 1, description: 'ISO date YYYY-MM-DD' },
        { month: '2026-02-15T12:34:56Z', expected: 2, description: 'ISO datetime with Z' },
        { month: '2026-03-10T08:00:00.000Z', expected: 3, description: 'ISO datetime with milliseconds' },
        { month: 'M04', expected: 4, description: 'M-prefix format M04' },
        { month: 'M4', expected: 4, description: 'M-prefix format M4 (no leading zero)' },
        { month: 'm05', expected: 5, description: 'lowercase m-prefix' },
        { month: '6', expected: 6, description: 'numeric string' },
        { month: 7, expected: 7, description: 'numeric value' },
      ];

      for (const testCase of testCases) {
        const normalized = normalizeInvoiceMonth(testCase.month);
        assert.strictEqual(
          normalized,
          testCase.expected,
          `${testCase.description}: ${testCase.month} should normalize to ${testCase.expected}`
        );
      }
    });

    it('should skip invoices with invalid month format', () => {
      const forecastRow: ForecastRow = {
        line_item_id: 'MOD-ARCH',
        rubroId: 'MOD-ARCH',
        description: 'Architect',
        month: 1,
        planned: 4000,
        forecast: 4000,
        actual: 0,
        variance: 0,
        last_updated: '2026-01-20T00:00:00Z',
        updated_by: 'system',
      };

      const invoiceWithInvalidMonth = {
        project_id: 'TEST-PROJECT-001',
        line_item_id: 'MOD-ARCH',
        amount: 4200,
        month: 'invalid-month-format', // Should fail to parse
        status: 'posted',
      };

      const normalizedMonth = normalizeInvoiceMonth(invoiceWithInvalidMonth.month);
      assert.strictEqual(normalizedMonth, 0, 'Invalid month should normalize to 0');

      const matches = matchInvoiceToCell(invoiceWithInvalidMonth, forecastRow);

      // Even if line_item_id matches, invalid month should prevent summing
      if (matches && normalizedMonth > 0 && forecastRow.month === normalizedMonth) {
        forecastRow.actual = (forecastRow.actual || 0) + invoiceWithInvalidMonth.amount;
      }

      assert.strictEqual(
        forecastRow.actual,
        0,
        'Invoice with invalid month should not update actual'
      );
    });

    it('should match invoice with project_id field to forecast row with projectId field', () => {
      const forecastRow: ForecastRow = {
        line_item_id: 'MOD-TEST',
        rubroId: 'MOD-TEST',
        description: 'Test Engineer',
        month: 1,
        planned: 1800,
        forecast: 1800,
        actual: 0,
        variance: 0,
        last_updated: '2026-01-20T00:00:00Z',
        updated_by: 'system',
        projectId: 'PROJECT-123', // camelCase
      };

      const invoice = {
        project_id: 'PROJECT-123', // snake_case
        line_item_id: 'MOD-TEST',
        amount: 1900,
        month: '2026-01-20',
        status: 'posted',
      };

      const normalizedMonth = normalizeInvoiceMonth(invoice.month);
      const matches = matchInvoiceToCell(invoice, forecastRow);
      
      assert.strictEqual(matches, true, 'Should match despite field name differences');

      if (matches && normalizedMonth > 0 && forecastRow.month === normalizedMonth) {
        forecastRow.actual = (forecastRow.actual || 0) + invoice.amount;
      }

      assert.strictEqual(
        forecastRow.actual,
        1900,
        'Should handle both project_id and projectId field names'
      );
    });
  });

  describe('Invoice Status Validation', () => {
    it('should filter invoices by valid statuses', () => {
      const VALID_INVOICE_STATUSES = ['matched', 'paid', 'approved', 'posted', 'received', 'validated'];
      
      const invoices = [
        { line_item_id: 'R1', status: 'posted', amount: 100 },
        { line_item_id: 'R2', status: 'paid', amount: 200 },
        { line_item_id: 'R3', status: 'draft', amount: 300 }, // Should be filtered
        { line_item_id: 'R4', status: 'cancelled', amount: 400 }, // Should be filtered
        { line_item_id: 'R5', status: 'approved', amount: 500 },
      ];

      const validInvoices = invoices.filter((inv) => {
        const status = inv.status?.toString().trim().toLowerCase();
        return status && VALID_INVOICE_STATUSES.includes(status);
      });

      assert.strictEqual(validInvoices.length, 3, 'Should filter to 3 valid invoices');
      assert.strictEqual(
        validInvoices.reduce((sum, inv) => sum + inv.amount, 0),
        800,
        'Total of valid invoices should be 800'
      );
    });
  });
});
