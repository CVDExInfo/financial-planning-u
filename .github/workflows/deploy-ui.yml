name: Deploy Finanzas UI

on:
  workflow_dispatch: {}
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: write

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-2' }}
  DEPLOYMENT_ENV: ${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
  FINANZAS_BUCKET_NAME: ${{ vars.FINANZAS_BUCKET_NAME || 'ukusi-ui-finanzas-prod' }}
  CLOUDFRONT_DIST_ID: ${{ vars.CLOUDFRONT_DIST_ID || 'EPQU7PVDLQUA' }}
  CF_DOMAIN: ${{ vars.CF_DOMAIN || 'd7t9x3j66yd8k.cloudfront.net' }}
  FINANZAS_CF_FUNCTION_NAME: ${{ vars.FINANZAS_CF_FUNCTION_NAME || 'finanzas-path-rewrite' }}
  FINZ_API_ID: ${{ vars.FINZ_API_ID || 'pyorjw6lbe' }}
  FINZ_API_STAGE: ${{ github.ref == 'refs/heads/main' && (vars.FINZ_API_STAGE_PROD || 'prod') || (vars.FINZ_API_STAGE_DEV || 'dev') }}
  EXPECTED_API_ID: ${{ vars.FINZ_API_ID || 'pyorjw6lbe' }}
  DEV_API_URL: ${{ vars.DEV_API_URL || '' }}
  COGNITO_USER_POOL_ID: ${{ vars.COGNITO_USER_POOL_ID }}
  COGNITO_WEB_CLIENT: ${{ vars.COGNITO_WEB_CLIENT }}
  COGNITO_DOMAIN: ${{ vars.COGNITO_DOMAIN }}
  COGNITO_IDENTITY_POOL_ID: ${{ vars.COGNITO_IDENTITY_POOL_ID || '' }}
  COGNITO_TESTER_USERNAME: ${{ vars.COGNITO_TESTER_USERNAME || '' }}
  COGNITO_TESTER_PASSWORD: ${{ vars.COGNITO_TESTER_PASSWORD || '' }}
  VITE_FINZ_ENABLED: ${{ vars.VITE_FINZ_ENABLED || 'true' }}
  VITE_USE_MOCKS: "false"

jobs:
  build-and-deploy-all:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Guard - workflow_dispatch uses latest main
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          set -euo pipefail
          LATEST_MAIN_SHA=$(git ls-remote origin refs/heads/main | awk '{print $1}')
          if [ -z "$LATEST_MAIN_SHA" ]; then
            echo "‚ùå Unable to resolve latest main SHA from origin"
            exit 1
          fi
          echo "Latest main SHA: $LATEST_MAIN_SHA"
          echo "Current SHA: ${GITHUB_SHA}"
          if [ "$LATEST_MAIN_SHA" != "${GITHUB_SHA}" ]; then
            echo "‚ùå workflow_dispatch is not on latest main. Re-run from latest main commit."
            exit 1
          fi
          echo "‚úÖ workflow_dispatch is on latest main SHA"

      - name: Preflight env
        run: |
          set -euo pipefail
          echo "üöÄ Deployment Environment: ${DEPLOYMENT_ENV}"
          for k in AWS_REGION FINANZAS_BUCKET_NAME CLOUDFRONT_DIST_ID FINZ_API_ID FINZ_API_STAGE COGNITO_USER_POOL_ID COGNITO_WEB_CLIENT COGNITO_DOMAIN; do
            v="${!k:-}"; [ -n "$v" ] || { echo "‚ùå Missing repo var: $k"; exit 1; }
          done
          printf '%s\n' "VITE_USE_MOCKS=false" >> "$GITHUB_ENV"
          sed -i 's/\r$//' "$GITHUB_ENV"
          echo "‚úÖ Env OK"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install CLI tools
        run: |
          set -euo pipefail
          echo "Installing required CLI tools for validation..."
          sudo apt-get update -qq
          # Explicitly install tools we rely on (including grep)
          sudo apt-get install -y -qq curl jq dnsutils grep coreutils unzip
          # Ensure AWS CLI v2 is available and up-to-date
          if ! command -v aws &> /dev/null; then
            echo "AWS CLI not found, installing AWS CLI v2..."
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
            unzip -q /tmp/awscliv2.zip -d /tmp
            sudo /tmp/aws/install
            rm -rf /tmp/awscliv2.zip /tmp/aws
          fi
          echo "Tool versions and paths (debug):"
          echo "  PATH=$PATH"
          echo "  grep: $(command -v grep || echo NOTFOUND)  ; grep --version 2>&1 || true"
          echo "  aws: $(aws --version 2>&1 || true)"
          echo "  jq: $(jq --version 2>&1 || true)"
          echo "‚úÖ CLI tools installed"

      - name: Install deps
        run: |
          set -e
          echo "Installing frontend dependencies (prefer lock; fallback to install)"
          if ! npm ci; then
            echo "‚ö†Ô∏è npm ci failed; running npm install"
            npm install
          fi

      - name: Lint (auto-fix if supported)
        run: |
          set -euo pipefail
          LINT_SCRIPT=$(node -p "require('./package.json').scripts && require('./package.json').scripts.lint || ''" || echo "")
          if [ -z "$LINT_SCRIPT" ]; then
            echo "‚ÑπÔ∏è  No lint script defined; skipping lint step"
            exit 0
          fi
          echo "‚ÑπÔ∏è  Running npm run lint -- --fix (best-effort auto-correct)"
          if ! npm run lint -- --fix; then
            echo "‚ö†Ô∏è  npm run lint -- --fix failed or not supported; will still run plain lint"
          fi
          echo "‚ÑπÔ∏è  Running npm run lint (gating)"
          npm run lint

      - name: Compute API base URL
        id: apibase
        run: |
          set -euo pipefail
          if [ -n "${DEV_API_URL}" ]; then
            BASE="${DEV_API_URL%/}"
            echo "‚úÖ Using DEV_API_URL override: $BASE"
          else
            BASE="https://${FINZ_API_ID}.execute-api.${AWS_REGION}.amazonaws.com/${FINZ_API_STAGE}"
            echo "‚úÖ Using constructed API endpoint: $BASE"
          fi
          if [ -z "$BASE" ]; then
            echo "‚ùå CRITICAL: API base URL is empty. Set DEV_API_URL repo variable or ensure FINZ_API_ID/AWS_REGION/FINZ_API_STAGE are set."
            exit 1
          fi
          HOST_WITH_PATH="${BASE#https://}"
          HOST="${HOST_WITH_PATH%%/*}"
          EXPECTED_HOST="${EXPECTED_API_ID}.execute-api.${AWS_REGION}.amazonaws.com"
          if [[ -n "${EXPECTED_API_ID}" && "$HOST" != "$EXPECTED_HOST" ]]; then
            echo "‚ö†Ô∏è  WARNING: API host ($HOST) does not match EXPECTED_API_ID ($EXPECTED_HOST)" >&2
          fi
          echo "üìù Setting VITE_API_BASE_URL=$BASE for Finanzas build"
          printf '%s\n' "VITE_API_BASE_URL=$BASE" >> "$GITHUB_ENV"
          sed -i 's/\r$//' "$GITHUB_ENV"

      - name: Export EXPECTED_API_BASE_URL for pre-build validation
        run: |
          set -euo pipefail
          : "${VITE_API_BASE_URL:?VITE_API_BASE_URL must be set at this point}"
          echo "Using EXPECTED_API_BASE_URL=${VITE_API_BASE_URL}"
          printf '%s\n' "EXPECTED_API_BASE_URL=${VITE_API_BASE_URL}" >> "$GITHUB_ENV"
          echo "‚úÖ EXPECTED_API_BASE_URL exported"

      - name: Guard - Stage/Environment Drift Check
        run: |
          set -euo pipefail
          ALLOW_DRIFT="${{ vars.ALLOW_STAGE_DRIFT || 'false' }}"
          echo "üîç Checking for stage/environment drift..."
          echo "   DEPLOYMENT_ENV: ${DEPLOYMENT_ENV}"
          echo "   FINZ_API_STAGE: ${FINZ_API_STAGE}"
          echo "   ALLOW_STAGE_DRIFT: ${ALLOW_DRIFT}"
          if [ "${DEPLOYMENT_ENV}" = "prod" ] && [ "${FINZ_API_STAGE}" != "prod" ]; then
            if [ "${ALLOW_DRIFT}" != "true" ]; then
              echo "‚ùå CRITICAL: Production deployment with non-production API stage"
              echo "   DEPLOYMENT_ENV is 'prod' but FINZ_API_STAGE is '${FINZ_API_STAGE}'"
              echo ""
              echo "üîß To fix:"
              echo "   1. Set FINZ_API_STAGE_PROD=prod in repository variables"
              echo "   2. Or set ALLOW_STAGE_DRIFT=true to override this check"
              exit 1
            else
              echo "‚ö†Ô∏è  WARNING: Stage drift allowed (ALLOW_STAGE_DRIFT=true)"
              echo "   Production deployment will use ${FINZ_API_STAGE} API"
            fi
          else
            echo "‚úÖ Stage/environment alignment verified"
          fi

      - name: Preflight API health
        run: |
          set -euo pipefail
          : ${VITE_API_BASE_URL:?VITE_API_BASE_URL missing after compute step}
          BASE="${VITE_API_BASE_URL%/}"
          echo "Checking ${BASE}/health before build..."
          STATUS=$(curl -sS -o /dev/null -w '%{http_code}' "${BASE}/health" || true)
          if [ "$STATUS" != "200" ]; then
            echo "‚ùå API /health preflight failed with HTTP $STATUS" >&2
            exit 1
          fi
          echo "‚úÖ API /health preflight ok"

      - name: Build Finanzas SDT Portal (base /finanzas/)
        env:
          BUILD_TARGET: finanzas
          VITE_API_BASE_URL: ${{ env.VITE_API_BASE_URL }}
          VITE_ACTA_BASE_URL: ${{ vars.VITE_ACTA_BASE_URL }}
          VITE_PREFACTURAS_URL: ${{ vars.VITE_PREFACTURAS_URL }}
          VITE_BASE_URL: "/finanzas/"
          VITE_FINZ_ENABLED: "true"
          VITE_USE_MOCKS: "false"
          VITE_PUBLIC_BASE: "/finanzas/"
          VITE_AWS_REGION: ${{ env.AWS_REGION }}
          VITE_COGNITO_REGION: ${{ env.AWS_REGION }}
          VITE_COGNITO_USER_POOL_ID: ${{ env.COGNITO_USER_POOL_ID }}
          VITE_COGNITO_CLIENT_ID: ${{ env.COGNITO_WEB_CLIENT }}
          VITE_COGNITO_IDENTITY_POOL_ID: ${{ env.COGNITO_IDENTITY_POOL_ID }}
          VITE_COGNITO_DOMAIN: ${{ env.COGNITO_DOMAIN }}
          VITE_CLOUDFRONT_URL: https://${{ env.CF_DOMAIN }}
        run: |
          set -euo pipefail
          VITE_API_BASE_URL="$(printf '%s' "$VITE_API_BASE_URL" | tr -d '\r\n')"
          VITE_API_BASE_URL="${VITE_API_BASE_URL%/}"
          if [ -z "$VITE_API_BASE_URL" ]; then
            echo "‚ùå CRITICAL: VITE_API_BASE_URL is empty"
            echo "   This variable is REQUIRED for Finanzas builds"
            echo "   Set DEV_API_URL in repository variables"
            exit 1
          fi
          echo "[Finanzas] BUILD_TARGET=$BUILD_TARGET"
          echo "[Finanzas] VITE_API_BASE_URL=$VITE_API_BASE_URL"
          echo "[Finanzas] Building Finanzas SDT Portal (base: /finanzas/)..."
          echo "[Finanzas] Environment: ${DEPLOYMENT_ENV}"
          export VITE_API_BASE_URL
          npm run build:finanzas || {
            echo "‚ùå Finanzas build failed"
            echo "   Build failed ‚Äî see errors above (TypeScript/esbuild). This is usually a code compile error, not VITE_API_BASE_URL."
            exit 1
          }
          echo "‚úÖ Finanzas Portal built ‚Üí dist-finanzas/"

      - name: Write Finanzas build info
        run: |
          set -euo pipefail
          BUILD_SHA="$(git rev-parse HEAD)"
          BUILD_TIME="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          cat > dist-finanzas/build-info.json <<EOF
          {
            "buildSha": "${BUILD_SHA}",
            "buildTimeUtc": "${BUILD_TIME}",
            "workflowRunId": "${GITHUB_RUN_ID}",
            "workflowRunAttempt": "${GITHUB_RUN_ATTEMPT}"
          }
          EOF
          echo "‚úÖ Wrote dist-finanzas/build-info.json"

      - name: Record Finanzas bundle hashes
        run: |
          set -euo pipefail
          ls -R dist-finanzas
          sha256sum dist-finanzas/assets/index-*.js dist-finanzas/assets/index-*.css > dist-finanzas-bundle-hashes.txt
          {
            echo "### Finanzas bundle hashes"
            echo ""
            cat dist-finanzas-bundle-hashes.txt
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload Finanzas bundle hash artifact
        uses: actions/upload-artifact@v4
        with:
          name: finanzas-bundle-hashes
          path: dist-finanzas-bundle-hashes.txt

      - name: Find previous successful Finanzas run
        id: prev_run
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          BRANCH_NAME="${GITHUB_REF##*/}"
          echo "üîé Looking for previous successful run on branch: $BRANCH_NAME"
          if ! RAW_JSON=$(gh run list \
              --workflow "Deploy Finanzas UI" \
              --branch "$BRANCH_NAME" \
              --json databaseId,headSha,conclusion,status \
              -L 20 2>/tmp/gh_run_list_err.log); then
            echo "‚ÑπÔ∏è  gh run list failed (likely permission issue). Skipping previous-run hash comparison."
            echo "----- gh run list stderr -----"
            cat /tmp/gh_run_list_err.log || true
            printf 'previous_run_found=false\n' >> "$GITHUB_OUTPUT"
            exit 0
          fi
          PREV_RUN_ID=$(printf '%s\n' "$RAW_JSON" \
            | jq -r --arg current "$GITHUB_SHA" '
                [ .[]
                  | select(.conclusion=="success" and .headSha != $current)
                ][0].databaseId // ""
              ')
          if [ -z "$PREV_RUN_ID" ]; then
            echo "‚ÑπÔ∏è  No previous successful run found for this branch (or only current SHA present)."
            printf 'previous_run_found=false\n' >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "‚úÖ Previous successful run id: $PREV_RUN_ID"
          mkdir -p /tmp/prev-hashes
          if gh run download "$PREV_RUN_ID" --name finanzas-bundle-hashes --dir /tmp/prev-hashes 2>/tmp/gh_run_download_err.log; then
            if [ -f /tmp/prev-hashes/dist-finanzas-bundle-hashes.txt ]; then
              printf 'previous_run_found=true\n' >> "$GITHUB_OUTPUT"
              printf 'previous_hash_file=/tmp/prev-hashes/dist-finanzas-bundle-hashes.txt\n' >> "$GITHUB_OUTPUT"
              echo "‚úÖ Previous hash file found at /tmp/prev-hashes/dist-finanzas-bundle-hashes.txt"
            else
              echo "‚ÑπÔ∏è  Previous run had no dist-finanzas-bundle-hashes.txt artifact."
              printf 'previous_run_found=false\n' >> "$GITHUB_OUTPUT"
            fi
          else
            echo "‚ÑπÔ∏è  gh run download failed (likely permission issue). Skipping previous-run hash comparison."
            echo "----- gh run download stderr -----"
            cat /tmp/gh_run_download_err.log || true
            printf 'previous_run_found=false\n' >> "$GITHUB_OUTPUT"
          fi

      - name: Compare bundle hashes with previous run
        if: steps.prev_run.outputs.previous_run_found == 'true'
        run: |
          set -euo pipefail
          PREV_FILE="${{ steps.prev_run.outputs.previous_hash_file }}"
          echo "üîç Comparing current bundle hashes with: $PREV_FILE"
          if diff -u "$PREV_FILE" dist-finanzas-bundle-hashes.txt; then
            echo "‚ÑπÔ∏è  Bundle hashes match previous successful run."
          else
            echo "‚ÑπÔ∏è  Bundle hashes differ from previous run (expected when Finanzas UI changed)."
          fi

      - name: Detect Finanzas UI changes in this commit
        id: finz_changes
        run: |
          set -euo pipefail
          COMPARE_REF="${{ github.event.before || '' }}"
          if [ -z "$COMPARE_REF" ]; then
            COMPARE_REF="HEAD~1"
          fi
          if ! git rev-parse "$COMPARE_REF" >/dev/null 2>&1; then
            COMPARE_REF="HEAD~1"
          fi
          CHANGED_FILES=$(git diff --name-only "$COMPARE_REF"...HEAD || git diff --name-only "$COMPARE_REF" HEAD || true)
          echo "$CHANGED_FILES" > /tmp/finz-changed-files.txt
          if echo "$CHANGED_FILES" | grep -E -q '^(src/|public/|index\.html|vite\.config\.ts|package\.json|tailwind\.config\.js|tsconfig|scripts/finanzas)'; then
            printf 'finz_changed=true\n' >> "$GITHUB_OUTPUT"
          else
            printf 'finz_changed=false\n' >> "$GITHUB_OUTPUT"
          fi
          {
            echo "### Finanzas file changes (detected vs $COMPARE_REF)"
            echo "$(wc -l < /tmp/finz-changed-files.txt) files changed"
            head -50 /tmp/finz-changed-files.txt
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Fail if bundle unchanged while Finanzas files changed
        if: steps.prev_run.outputs.previous_run_found == 'true'
        run: |
          set -euo pipefail
          if cmp -s dist-finanzas-bundle-hashes.txt "${{ steps.prev_run.outputs.previous_hash_file }}"; then
            if [ "${{ steps.finz_changes.outputs.finz_changed }}" = "true" ]; then
              echo "‚ùå Finanzas bundle hashes match previous successful deploy, but Finanzas files changed."
              exit 1
            else
              echo "‚ÑπÔ∏è Bundle hashes unchanged and no Finanzas-specific files changed; continuing."
            fi
          else
            echo "‚úÖ Bundle hashes differ from previous successful deploy."
          fi

      - name: Verify API URL embedded in Finanzas bundle
        env:
          VITE_API_BASE_URL: ${{ env.VITE_API_BASE_URL }}
        run: |
          set -euo pipefail
          VITE_API_BASE_URL="$(printf '%s' "$VITE_API_BASE_URL" | tr -d '\r')"
          VITE_API_BASE_URL="${VITE_API_BASE_URL%/}"
          DIST="dist-finanzas"
          echo "üîç Searching for VITE_API_BASE_URL in build artifacts..."
          if ! grep -R --binary-files=text -F "$VITE_API_BASE_URL" "$DIST" >/dev/null; then
            echo "‚ùå CRITICAL: VITE_API_BASE_URL ($VITE_API_BASE_URL) not found in $DIST"
            echo "   This means the API URL was not injected during build"
            echo ""
            echo "üîß Troubleshooting:"
            echo "   1. Check that VITE_API_BASE_URL was set during build"
            echo "   2. Verify vite.config.ts is properly injecting the value"
            echo "   3. Review build logs for Vite configuration errors"
            exit 1
          fi
          echo "‚úÖ VITE_API_BASE_URL found in Finanzas bundle"
          echo "üìã Sample occurrences:"
          grep -R --binary-files=text -F "$VITE_API_BASE_URL" "$DIST" | head -3 || true

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.OIDC_AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: deploy-ui-${{ github.run_id }}

      - name: Verify identity
        run: aws sts get-caller-identity

      - name: Guard - S3 buckets and CloudFront exist
        run: |
          set -euo pipefail
          aws s3api head-bucket --bucket "${FINANZAS_BUCKET_NAME}" >/dev/null || { echo "‚ùå Missing Finanzas bucket ${FINANZAS_BUCKET_NAME}"; exit 1; }
          aws cloudfront get-distribution --id "${CLOUDFRONT_DIST_ID}" >/dev/null || { echo "‚ùå Missing CloudFront distribution ${CLOUDFRONT_DIST_ID}"; exit 1; }
          echo "‚úÖ Buckets & CloudFront found"

      - name: Guard - API endpoint present (VITE_API_BASE_URL)
        run: |
          set -euo pipefail
          : ${VITE_API_BASE_URL:?VITE_API_BASE_URL missing}
          BASE="${VITE_API_BASE_URL%/}"
          HOST_ID=$(echo "$BASE" | awk -F'[/.]' '{print $3}')
          : ${EXPECTED_API_ID:?EXPECTED_API_ID missing}
          if [ "$HOST_ID" != "$EXPECTED_API_ID" ]; then
            echo "‚ùå Expected API id ${EXPECTED_API_ID}, got ${HOST_ID}"; exit 1;
          fi
          CODE=$(curl -sS -o /dev/null -w '%{http_code}' "$BASE/health" || true)
          if [ "$CODE" != "200" ]; then
            echo "‚ùå /health returned $CODE ‚Äî check stage deployment"; exit 1;
          fi
          echo "‚úÖ API endpoint ID and /health verified: $BASE"

      - name: Guard - Baseline APIs available (authorized)
        run: |
          set -euo pipefail
          if [ -z "${COGNITO_TESTER_USERNAME:-}" ] || [ -z "${COGNITO_TESTER_PASSWORD:-}" ]; then
            echo "‚ö†Ô∏è COGNITO_TESTER_USERNAME/COGNITO_TESTER_PASSWORD not set; skipping baseline API guard."
            exit 0
          fi
          : ${AWS_REGION:?AWS_REGION missing}
          : ${COGNITO_USER_POOL_ID:?COGNITO_USER_POOL_ID missing}
          : ${COGNITO_WEB_CLIENT:?COGNITO_WEB_CLIENT missing}
          TOKEN=$(bash scripts/cognito/get-jwt.sh)
          BASE="${VITE_API_BASE_URL%/}"
          PROJECT_STATUS=$(curl -sS -o /tmp/projects.json -w '%{http_code}' -H "Authorization: Bearer ${TOKEN}" "${BASE}/projects")
          if [ "$PROJECT_STATUS" != "200" ]; then
            echo "‚ùå /projects returned HTTP $PROJECT_STATUS"
            cat /tmp/projects.json || true
            exit 1
          fi
          PROJECT_ID=$(jq -r '.data[0].projectId // .data[0].project_id // .data[0].id // empty' /tmp/projects.json)
          if [ -z "$PROJECT_ID" ]; then
            echo "‚ö†Ô∏è No project id found in /projects response; skipping baseline checks"
            exit 0
          fi
          echo "‚úÖ Using project id: $PROJECT_ID"
          BASELINE_STATUS=$(curl -sS -o /tmp/baseline-summary.json -w '%{http_code}' -H "Authorization: Bearer ${TOKEN}" "${BASE}/projects/${PROJECT_ID}/baseline-summary")
          if [ "$BASELINE_STATUS" != "200" ]; then
            echo "‚ùå /projects/${PROJECT_ID}/baseline-summary returned HTTP $BASELINE_STATUS"
            cat /tmp/baseline-summary.json || true
            exit 1
          fi
          BASELINE_ID=$(jq -r '.baselineId // .baseline_id // empty' /tmp/baseline-summary.json)
          if [ -z "$BASELINE_ID" ]; then
            echo "‚ö†Ô∏è No baselineId found for project ${PROJECT_ID}; skipping baseline detail checks"
            exit 0
          fi
          echo "‚úÖ Using baseline id: $BASELINE_ID"
          DETAIL_STATUS=$(curl -sS -o /tmp/baseline-detail.json -w '%{http_code}' -H "Authorization: Bearer ${TOKEN}" "${BASE}/projects/${PROJECT_ID}/baselines/${BASELINE_ID}")
          if [ "$DETAIL_STATUS" != "200" ]; then
            echo "‚ùå /projects/${PROJECT_ID}/baselines/${BASELINE_ID} returned HTTP $DETAIL_STATUS"
            cat /tmp/baseline-detail.json || true
            exit 1
          fi
          echo "‚úÖ Baseline detail endpoint reachable"

      - name: Guard - Finanzas build artifacts
        run: |
          set -euo pipefail
          if grep -R -nE 'src="/assets/|href="/assets/' dist-finanzas/index.html; then
            echo "‚ùå dist-finanzas/index.html points to /assets/* (missing base '/finanzas/')"; exit 1;
          fi
          if [ ! -f dist-finanzas/auth/callback.html ]; then
            echo "‚ùå Missing auth callback asset at dist-finanzas/auth/callback.html (expected from public/auth/callback.html)"
            exit 1
          fi
          if [ -f dist-finanzas/finanzas/auth/callback.html ]; then
            echo "‚ùå Unexpected nested callback found at dist-finanzas/finanzas/auth/callback.html"
            echo "   This would publish to /finanzas/finanzas/auth/callback.html and break the Hosted UI redirect"
            exit 1
          fi
          if grep -R -i 'github\.dev\|codespaces' dist-finanzas/ 2>/dev/null; then
            echo "‚ùå Build contains github.dev/codespaces references"; exit 1;
          fi
          if find dist-finanzas -name "aws-exports.js" -o -name "aws-exports.ts" | grep -q .; then
            echo "‚ùå CRITICAL: aws-exports.js found in Finanzas build!";
            echo "   aws-exports.js is a PMO/Amplify concern and should NOT be in Finanzas";
            exit 1;
          fi
          echo "‚úÖ Finanzas build artifacts look good"

      - name: Upload Finanzas assets to S3 (/finanzas/assets with long cache)
        run: |
          set -euo pipefail
          aws s3 sync dist-finanzas/assets/ "s3://${FINANZAS_BUCKET_NAME}/finanzas/assets/" \
            --exclude '*.map' \
            --cache-control "public, max-age=31536000, immutable" \
            --delete
          echo "‚úÖ Finanzas assets uploaded to s3://${FINANZAS_BUCKET_NAME}/finanzas/assets/"

      - name: Upload Finanzas non-asset files to S3 (/finanzas with no-cache)
        run: |
          set -euo pipefail
          aws s3 sync dist-finanzas/ "s3://${FINANZAS_BUCKET_NAME}/finanzas/" \
            --exclude 'assets/*' \
            --exclude 'index.html' \
            --exclude '*.map' \
            --exclude 'docs/*' \
            --exclude 'test-helper.html' \
            --cache-control "no-cache" \
            --delete
          echo "‚úÖ Finanzas non-asset files uploaded to s3://${FINANZAS_BUCKET_NAME}/finanzas/"

      - name: Upload Finanzas index.html last (no-cache)
        run: |
          set -euo pipefail
          aws s3 cp dist-finanzas/index.html "s3://${FINANZAS_BUCKET_NAME}/finanzas/index.html" \
            --cache-control "no-cache" \
            --content-type "text/html; charset=utf-8"
          echo "‚úÖ Finanzas index.html uploaded last to s3://${FINANZAS_BUCKET_NAME}/finanzas/index.html"

      - name: Debug - list S3 assets after upload
        run: |
          set -euo pipefail
          echo "Post-upload S3 keys under finanzas/assets/:"
          aws s3api list-objects-v2 --bucket "${FINANZAS_BUCKET_NAME}" --prefix "finanzas/assets/" --output json \
            | jq -r '.Contents[]? | "\(.Key)\t\(.LastModified)\t\(.Size)\t\(.StorageClass)\t\(.ETag // "")"' \
            | sort -u || true

      - name: Verify Finanzas S3 manifest matches local build
        run: |
          set -euo pipefail
          find dist-finanzas -type f \
            ! -name '*.map' \
            ! -name '*.docx' \
            ! -path 'dist-finanzas/docs/*' \
            -print \
            | sed 's|^dist-finanzas/||' \
            | sort > /tmp/local-finanzas-manifest.txt
          if ! aws s3api list-objects-v2 \
            --bucket "${FINANZAS_BUCKET_NAME}" \
            --prefix "finanzas/" \
            --output json 2>/tmp/s3_finanzas_list_err.log \
            | jq -r '.Contents[]?.Key
              | sub("^finanzas/"; "")
              | select(. | endswith(".map") | not)
              | select(. | endswith(".docx") | not)
              | select(. | startswith("docs/") | not)
            ' \
            | sort > /tmp/s3-finanzas-manifest.txt; then
            echo "----- aws s3api list-objects-v2 stderr -----"
            sed -n '1,200p' /tmp/s3_finanzas_list_err.log || true
            if grep -qi "AccessDenied\|Access Denied" /tmp/s3_finanzas_list_err.log; then
              echo "‚ö†Ô∏è  Unable to list S3 assets under finanzas/ due to AccessDenied."
              echo "   Skipping S3 manifest verification (no s3:ListBucket on ${FINANZAS_BUCKET_NAME})."
              exit 0
            else
              echo "‚ùå Unable to list S3 assets under finanzas/"
              exit 1
            fi
          fi
          echo "üîç Comparing local vs S3 manifests (excluding .map/.docx files and docs/ prefix)..."
          if ! diff -u /tmp/local-finanzas-manifest.txt /tmp/s3-finanzas-manifest.txt; then
            echo "‚ùå Finanzas S3 manifest mismatch ‚Äî bucket drift detected"
            echo "   Ensure sync completed successfully and CloudFront invalidation is executed"
            exit 1
          fi
          echo "‚úÖ Finanzas S3 manifest matches local build"

      - name: Verify auth callback in S3
        run: |
          set -euo pipefail
          if ! aws s3api head-object --bucket "${FINANZAS_BUCKET_NAME}" --key "finanzas/auth/callback.html" >/dev/null 2>&1; then
            echo "‚ùå auth/callback.html missing in S3 at finanzas/auth/callback.html"
            echo "   Ensure public/auth/callback.html exists and dist-finanzas/auth/callback.html is produced by the build"
            exit 1
          fi
          echo "‚úÖ auth/callback.html present in S3 at finanzas/auth/callback.html"

      - name: Guard - Verify CloudFront /finanzas/* Behavior (CRITICAL)
        run: |
          set -euo pipefail
          BEHAVIOR_COUNT=$(aws cloudfront get-distribution-config \
            --id "${CLOUDFRONT_DIST_ID}" \
            --query 'DistributionConfig.CacheBehaviors.Items[?PathPattern==`/finanzas/*`] | length(@)' \
            --output text)
          if [ "$BEHAVIOR_COUNT" != "1" ]; then
            echo "‚ùå CRITICAL: /finanzas/* behavior missing in CloudFront ${CLOUDFRONT_DIST_ID}"; exit 1;
          fi
          echo "‚úÖ /finanzas/* behavior configured"

      - name: Guard - Verify CloudFront function association for /finanzas/* (CRITICAL)
        run: |
          set -euo pipefail
          CONFIG_JSON=$(aws cloudfront get-distribution-config --id "${CLOUDFRONT_DIST_ID}")
          FUNCTION_MATCH=$(printf '%s' "$CONFIG_JSON" | jq -r \
            --arg path "/finanzas/*" \
            --arg fn "${FINANZAS_CF_FUNCTION_NAME}" \
            '.DistributionConfig.CacheBehaviors.Items[]
              | select(.PathPattern==$path)
              | .FunctionAssociations.Items[]?
              | select(.EventType=="viewer-request")
              | .FunctionARN
              | select(contains($fn))
            ' | head -n 1)
          if [ -z "$FUNCTION_MATCH" ]; then
            echo "‚ùå CRITICAL: CloudFront function ${FINANZAS_CF_FUNCTION_NAME} not associated (viewer-request) to /finanzas/*";
            exit 1;
          fi
          echo "‚úÖ /finanzas/* behavior uses function: ${FINANZAS_CF_FUNCTION_NAME}"

      - name: Invalidate CloudFront (Finanzas SPA shell + assets)
        run: |
          set -euo pipefail
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "${CLOUDFRONT_DIST_ID}" \
            --paths '/finanzas' '/finanzas/' '/finanzas/index.html' '/finanzas/assets/*' \
            --query 'Invalidation.Id' --output text)
          echo "‚úÖ Invalidation queued: $INVALIDATION_ID"

      - name: UI Smoke (Finanzas /finanzas/)
        run: |
          set -euo pipefail
          DOMAIN="${CF_DOMAIN}"
          if [ -z "$DOMAIN" ]; then
            DOMAIN=$(aws cloudfront get-distribution --id "$CLOUDFRONT_DIST_ID" --query 'Distribution.DomainName' --output text)
          fi
          FINZ="https://${DOMAIN}/finanzas/"
          echo "üåê Testing CloudFront UI accessibility: $FINZ"
          STATUS=$(curl -sS -o /tmp/finanzas-cf-html.txt -w '%{http_code}' "$FINZ")
          echo "   HTTP Status: $STATUS"
          if [ "$STATUS" != "200" ]; then
            echo "‚ùå Finanzas portal not accessible (HTTP $STATUS)"
            exit 1
          fi
          echo "‚úÖ CloudFront UI accessible (HTTP 200)"
          if grep -q "/finanzas/assets/" /tmp/finanzas-cf-html.txt; then
            echo "‚úÖ HTML contains /finanzas/assets/ references"
          else
            echo "‚ö†Ô∏è  HTML missing /finanzas/assets/ references (may indicate CloudFront cache not yet updated)"
            echo "   This is expected immediately after deployment - CloudFront invalidation may still be propagating"
          fi
          # Show sample of what was found (for debugging)
          grep -oE '/finanzas/assets/[^"]+\.(js|css)' /tmp/finanzas-cf-html.txt | sort -u | head -20 || true

      - name: Deploy smoke test (CloudFront HTML matches S3 assets)
        run: |
          set -euo pipefail
          DOMAIN="${CF_DOMAIN}"
          if [ -z "$DOMAIN" ]; then
            DOMAIN=$(aws cloudfront get-distribution --id "$CLOUDFRONT_DIST_ID" --query 'Distribution.DomainName' --output text)
          fi
          FINZ="https://${DOMAIN}/finanzas/"
          HTML=$(curl -sS "$FINZ")
          ASSET_PATHS=$(printf '%s' "$HTML" | grep -oE '/finanzas/assets/[^"]+\.(js|css)' | sort -u)
          if [ -z "$ASSET_PATHS" ]; then
            echo "‚ùå No /finanzas/assets references found in CloudFront HTML"
            exit 1
          fi
          echo "$ASSET_PATHS" | while read -r PATH; do
            KEY="${PATH#/}"
            aws s3api head-object --bucket "${FINANZAS_BUCKET_NAME}" --key "$KEY" >/dev/null \
              || { echo "‚ùå Missing asset in S3: s3://${FINANZAS_BUCKET_NAME}/$KEY"; exit 1; }
            echo "‚úÖ Asset present in S3: $KEY"
          done

      - name: Deep-route SPA smoke test
        run: |
          set -euo pipefail
          DOMAIN="${CF_DOMAIN}"
          if [ -z "$DOMAIN" ]; then
            DOMAIN=$(aws cloudfront get-distribution --id "$CLOUDFRONT_DIST_ID" --query 'Distribution.DomainName' --output text)
          fi
          FINZ="https://${DOMAIN}/finanzas/"
          # Example deep route to verify SPA routing (adjust path if you have known deep routes)
          DEEP="/finanzas/sdmt/cost"
          STATUS=$(curl -sS -o /tmp/finanzas-deep.html -w '%{http_code}' "${FINZ}${DEEP}")
          echo "Deep route ${DEEP} HTTP: $STATUS"
          if [ "$STATUS" != "200" ]; then
            echo "‚ùå Deep-route SPA smoke test failed (HTTP $STATUS)"
            exit 1
          fi
          echo "‚úÖ Deep-route SPA smoke test passed (HTTP 200)"

      - name: Finalize
        run: |
          set -euo pipefail
          echo "‚úÖ Deploy Finanzas UI workflow completed successfully"
