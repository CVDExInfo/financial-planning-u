name: Deploy Finanzas UI

on:
  workflow_dispatch: {}
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: write

concurrency:
  group: deploy-finanzas-ui-${{ github.ref }}
  cancel-in-progress: true

# --------- GLOBAL ENV (kept intentionally minimal) ----------
env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-2' }}
  # S3 bucket for Finanzas (PMO is deployed by acta-ui repo)
  FINANZAS_BUCKET_NAME: ${{ vars.FINANZAS_BUCKET_NAME || 'ukusi-ui-finanzas-prod' }}
  # CloudFront (single distribution)
  CLOUDFRONT_DIST_ID: ${{ vars.CLOUDFRONT_DIST_ID || 'EPQU7PVDLQXUA' }}
  CF_DOMAIN: ${{ vars.CF_DOMAIN || 'd7t9x3j66yd8k.cloudfront.net' }}
  # API ID / Stage (ID from vars)
  FINZ_API_ID: ${{ vars.FINZ_API_ID || 'pyorjw6lbe' }}
  EXPECTED_API_ID: ${{ vars.FINZ_API_ID || 'pyorjw6lbe' }}
  # Optional escape hatch: explicit API base (dev-only override, but OK to use as canonical)
  DEV_API_URL: ${{ vars.DEV_API_URL || '' }}
  # Cognito Configuration (required for authentication)
  COGNITO_USER_POOL_ID: ${{ vars.COGNITO_USER_POOL_ID }}
  COGNITO_WEB_CLIENT: ${{ vars.COGNITO_WEB_CLIENT }}
  COGNITO_DOMAIN: ${{ vars.COGNITO_DOMAIN }}
  COGNITO_IDENTITY_POOL_ID: ${{ vars.COGNITO_IDENTITY_POOL_ID || '' }}
  # Frontend feature flags
  VITE_FINZ_ENABLED: ${{ vars.VITE_FINZ_ENABLED || 'true' }}
  VITE_USE_MOCKS: "false"
  # Forecast UI feature flags (default to false for safety)
  VITE_FINZ_NEW_FORECAST_LAYOUT: ${{ vars.VITE_FINZ_NEW_FORECAST_LAYOUT || 'true' }}
  VITE_FINZ_HIDE_REAL_ANNUAL_KPIS: ${{ vars.VITE_FINZ_HIDE_REAL_ANNUAL_KPIS || 'false' }}
  VITE_FINZ_HIDE_PROJECT_SUMMARY: ${{ vars.VITE_FINZ_HIDE_PROJECT_SUMMARY || 'true' }}
  VITE_FINZ_HIDE_KEY_TRENDS: ${{ vars.VITE_FINZ_HIDE_KEY_TRENDS || 'false' }}
  VITE_FINZ_SHOW_KEYTRENDS: ${{ vars.VITE_FINZ_SHOW_KEYTRENDS || 'false' }}

jobs:
  build-and-deploy-all:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---------- Compute branch-aware env vars (robust & debuggable) ----------
      - name: Compute branch-aware env vars
        id: compute_env
        shell: bash
        run: |
          set -euo pipefail

          # DEPLOYMENT_ENV: prod only when main branch
          if [[ "${GITHUB_REF}" == "refs/heads/main" ]]; then
            DEPLOYMENT_ENV="prod"
          else
            DEPLOYMENT_ENV="dev"
          fi

          # FINZ_API_STAGE prefer explicit vars when deploying main, else dev fallback
          if [[ "${GITHUB_REF}" == "refs/heads/main" ]]; then
            if [[ -n "${{ vars.FINZ_API_STAGE_PROD }}" ]]; then
              FINZ_API_STAGE="${{ vars.FINZ_API_STAGE_PROD }}"
            else
              FINZ_API_STAGE="prod"
            fi
          else
            if [[ -n "${{ vars.FINZ_API_STAGE_DEV }}" ]]; then
              FINZ_API_STAGE="${{ vars.FINZ_API_STAGE_DEV }}"
            else
              FINZ_API_STAGE="dev"
            fi
          fi

          # VITE_CLOUDFRONT_URL (computed here to avoid format() expression usage)
          CF_DOMAIN="${CF_DOMAIN:-${{ vars.CF_DOMAIN || 'd7t9x3j66yd8k.cloudfront.net' }}}"
          VITE_CLOUDFRONT_URL="https://${CF_DOMAIN}"

          echo "DEPLOYMENT_ENV=${DEPLOYMENT_ENV}" >> "$GITHUB_ENV"
          echo "FINZ_API_STAGE=${FINZ_API_STAGE}" >> "$GITHUB_ENV"
          echo "VITE_CLOUDFRONT_URL=${VITE_CLOUDFRONT_URL}" >> "$GITHUB_ENV"

          echo "Computed values:"
          echo "  DEPLOYMENT_ENV=${DEPLOYMENT_ENV}"
          echo "  FINZ_API_STAGE=${FINZ_API_STAGE}"
          echo "  VITE_CLOUDFRONT_URL=${VITE_CLOUDFRONT_URL}"

      # ---- Preflight env (same strategy as before) ----
      - name: Preflight env
        shell: bash
        run: |
          set -euo pipefail
          echo "üöÄ Deployment Environment: ${DEPLOYMENT_ENV:-<missing>}"
          for k in AWS_REGION FINANZAS_BUCKET_NAME CLOUDFRONT_DIST_ID FINZ_API_ID FINZ_API_STAGE COGNITO_USER_POOL_ID COGNITO_WEB_CLIENT COGNITO_DOMAIN; do
            v="${!k:-}"; [ -n "$v" ] || { echo "‚ùå Missing repo var: $k"; exit 1; }
          done
          printf '%s\n' "VITE_USE_MOCKS=false" >> "$GITHUB_ENV"
          if [ -n "${CF_DOMAIN:-}" ]; then
            printf '%s\n' "CF_DOMAIN_URL=https://${CF_DOMAIN}" >> "$GITHUB_ENV"
          else
            echo "‚ùå CF_DOMAIN not set"
            exit 1
          fi
          sed -i 's/\r$//' "$GITHUB_ENV"
          echo "‚úÖ Env OK"

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "pnpm"

      - name: Install CLI tools
        shell: bash
        run: |
          set -euo pipefail
          echo "Installing required CLI tools for validation..."
          sudo apt-get update -qq
          sudo apt-get install -y -qq curl jq dnsutils
          echo "‚úÖ CLI tools installed"

      - name: Install deps
        shell: bash
        run: |
          set -euo pipefail
          echo "Installing frontend dependencies with pnpm (frozen lockfile)"
          rm -rf node_modules
          pnpm install --frozen-lockfile
          echo "‚úÖ Dependencies installed with pnpm"

      # ---- Lint (auto-fix where possible, then gate) ----
      - name: Lint (auto-fix if supported)
        shell: bash
        run: |
          set -euo pipefail
          LINT_SCRIPT=$(node -p "require('./package.json').scripts && require('./package.json').scripts.lint || ''" || echo "")
          if [ -z "$LINT_SCRIPT" ]; then
            echo "‚ÑπÔ∏è  No lint script defined; skipping lint step"
            exit 0
          fi
          echo "‚ÑπÔ∏è  Running npm run lint -- --fix (best-effort auto-correct)"
          if ! npm run lint -- --fix; then
            echo "‚ö†Ô∏è  npm run lint -- --fix failed or not supported; will still run plain lint"
          fi
          echo "‚ÑπÔ∏è  Running npm run lint (gating)"
          npm run lint

      # ---- CI Guard 1: Clean build caches (prevent stale bundles) ----
      - name: Clean build caches (prevent stale bundles)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf dist-finanzas dist .vite node_modules/.cache || true
          echo "‚úÖ Local build cache removed"

      # ---- Compute the API base URL for the build (DEV_API_URL wins, otherwise derive) ----
      - name: Compute API base URL
        id: apibase
        shell: bash
        run: |
          set -euo pipefail

          # prefer DEV_API_URL if set
          if [ -n "${DEV_API_URL:-}" ]; then
            BASE="${DEV_API_URL%/}"
            echo "‚úÖ Using DEV_API_URL override: $BASE"
          else
            BASE="https://${FINZ_API_ID}.execute-api.${AWS_REGION}.amazonaws.com/${FINZ_API_STAGE}"
            echo "‚úÖ Using constructed API endpoint: $BASE"
          fi

          if [ -z "$BASE" ]; then
            echo "‚ùå CRITICAL: API base URL is empty. Set DEV_API_URL repo variable or ensure FINZ_API_ID/AWS_REGION/FINZ_API_STAGE are set."
            exit 1
          fi

          HOST_WITH_PATH="${BASE#https://}"
          HOST="${HOST_WITH_PATH%%/*}"
          EXPECTED_HOST="${EXPECTED_API_ID}.execute-api.${AWS_REGION}.amazonaws.com"
          if [[ -n "${EXPECTED_API_ID}" && "$HOST" != "$EXPECTED_HOST" ]]; then
            echo "‚ö†Ô∏è  WARNING: API host ($HOST) does not match EXPECTED_API_ID ($EXPECTED_HOST)" >&2
          fi

          echo "üìù Setting VITE_API_BASE_URL=$BASE for Finanzas build"
          printf '%s\n' "VITE_API_BASE_URL=$BASE" >> "$GITHUB_ENV"
          # make VITE_CLOUDFRONT_URL available too (computed earlier in compute step)
          printf '%s\n' "VITE_CLOUDFRONT_URL=${VITE_CLOUDFRONT_URL}" >> "$GITHUB_ENV"
          sed -i 's/\r$//' "$GITHUB_ENV"

      - name: Build Finanzas SDT Portal (base /finanzas/)
        env:
          BUILD_TARGET: finanzas
          VITE_API_BASE_URL: ${{ env.VITE_API_BASE_URL }}
          VITE_ACTA_BASE_URL: ${{ vars.VITE_ACTA_BASE_URL }}
          VITE_PREFACTURAS_URL: ${{ vars.VITE_PREFACTURAS_URL }}
          VITE_BASE_URL: "/finanzas/"
          VITE_FINZ_ENABLED: "true"
          VITE_USE_MOCKS: "false"
          VITE_PUBLIC_BASE: "/finanzas/"
          VITE_AWS_REGION: ${{ env.AWS_REGION }}
          VITE_COGNITO_REGION: ${{ env.AWS_REGION }}
          VITE_COGNITO_USER_POOL_ID: ${{ env.COGNITO_USER_POOL_ID }}
          VITE_COGNITO_CLIENT_ID: ${{ env.COGNITO_WEB_CLIENT }}
          VITE_COGNITO_IDENTITY_POOL_ID: ${{ env.COGNITO_IDENTITY_POOL_ID }}
          VITE_COGNITO_DOMAIN: ${{ env.COGNITO_DOMAIN }}
          VITE_CLOUDFRONT_URL: ${{ env.VITE_CLOUDFRONT_URL }}
          # Forecast UI feature flags
          VITE_FINZ_NEW_FORECAST_LAYOUT: ${{ env.VITE_FINZ_NEW_FORECAST_LAYOUT }}
          VITE_FINZ_HIDE_REAL_ANNUAL_KPIS: ${{ env.VITE_FINZ_HIDE_REAL_ANNUAL_KPIS }}
          VITE_FINZ_HIDE_PROJECT_SUMMARY: ${{ env.VITE_FINZ_HIDE_PROJECT_SUMMARY }}
          VITE_FINZ_HIDE_KEY_TRENDS: ${{ env.VITE_FINZ_HIDE_KEY_TRENDS }}
          VITE_FINZ_SHOW_KEYTRENDS: ${{ env.VITE_FINZ_SHOW_KEYTRENDS }}
        run: |
          set -euo pipefail
          VITE_API_BASE_URL="$(printf '%s' "$VITE_API_BASE_URL" | tr -d '\r\n')"
          VITE_API_BASE_URL="${VITE_API_BASE_URL%/}"
          if [ -z "$VITE_API_BASE_URL" ]; then
            echo "‚ùå CRITICAL: VITE_API_BASE_URL is empty"
            exit 1
          fi
          echo "[Finanzas] BUILD_TARGET=$BUILD_TARGET"
          echo "[Finanzas] VITE_API_BASE_URL=$VITE_API_BASE_URL"
          echo "[Finanzas] Building Finanzas SDT Portal (base: /finanzas/)..."
          echo "[Finanzas] Environment: ${DEPLOYMENT_ENV:-<missing>}"
          export VITE_API_BASE_URL
          BUILD_TARGET=finanzas pnpm -s run build || {
            echo "‚ùå Finanzas build failed"
            exit 1
          }
          echo "‚úÖ Finanzas Portal built ‚Üí dist-finanzas/"

      # ---- CI Guard 2: Verify build produced JS/CSS bundles ----
      - name: Verify build produced JS/CSS bundles
        shell: bash
        run: |
          set -euo pipefail
          # Check if index JS bundle exists
          if ! compgen -G "dist-finanzas/assets/index-*.js" > /dev/null; then
            echo "‚ùå No JS bundles found in dist-finanzas/assets. Build likely failed or output path changed."
            exit 1
          fi
          # Check if index CSS bundle exists
          if ! compgen -G "dist-finanzas/assets/index-*.css" > /dev/null; then
            echo "‚ùå No CSS bundles found in dist-finanzas/assets. Build likely failed or output path changed."
            exit 1
          fi
          echo "‚úÖ Bundle assets exist:"
          ls -l dist-finanzas/assets/index-*.js dist-finanzas/assets/index-*.css || true
          sha256sum dist-finanzas/assets/index-*.js dist-finanzas/assets/index-*.css || true

      - name: Write Finanzas deployment metadata
        run: bash scripts/write-deployment-meta.sh dist-finanzas

      - name: Record Finanzas bundle hashes
        run: |
          set -euo pipefail
          ls -R dist-finanzas
          sha256sum dist-finanzas/assets/index-*.js dist-finanzas/assets/index-*.css > dist-finanzas-bundle-hashes.txt
          {
            echo "### Finanzas bundle hashes"
            echo ""
            cat dist-finanzas-bundle-hashes.txt
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload Finanzas bundle hash artifact
        uses: actions/upload-artifact@v4
        with:
          name: finanzas-bundle-hashes
          path: dist-finanzas-bundle-hashes.txt

      - name: Find previous successful Finanzas run
        id: prev_run
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          if ! command -v gh >/dev/null 2>&1; then
            echo "‚ÑπÔ∏è  gh CLI not available on runner; skipping previous-run hash comparison."
            printf 'previous_run_found=false\n' >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BRANCH_NAME="${GITHUB_REF##*/}"
          echo "üîé Looking for previous successful run on branch: $BRANCH_NAME"

          # Try to fetch last 20 runs; if this fails (e.g. 403), degrade gracefully
          if ! RAW_JSON=$(gh run list \
              --workflow "Deploy Finanzas UI" \
              --branch "$BRANCH_NAME" \
              --json databaseId,headSha,conclusion,status \
              -L 20 2>/tmp/gh_run_list_err.log); then
            echo "‚ÑπÔ∏è  gh run list failed (likely permission issue). Skipping previous-run hash comparison."
            echo "----- gh run list stderr -----"
            cat /tmp/gh_run_list_err.log || true
            printf 'previous_run_found=false\n' >> "$GITHUB_OUTPUT"
            exit 0
          fi

          PREV_RUN_ID=$(printf '%s\n' "$RAW_JSON" \
            | jq -r --arg current "$GITHUB_SHA" '
                [ .[]
                  | select(.conclusion=="success" and .headSha != $current)
                ][0].databaseId // ""
              ')

          if [ -z "$PREV_RUN_ID" ]; then
            echo "‚ÑπÔ∏è  No previous successful run found for this branch (or only current SHA present)."
            printf 'previous_run_found=false\n' >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "‚úÖ Previous successful run id: $PREV_RUN_ID"

          mkdir -p /tmp/prev-hashes

          if gh run download "$PREV_RUN_ID" --name finanzas-bundle-hashes --dir /tmp/prev-hashes 2>/tmp/gh_run_download_err.log; then
            if [ -f /tmp/prev-hashes/dist-finanzas-bundle-hashes.txt ]; then
              printf 'previous_run_found=true\n' >> "$GITHUB_OUTPUT"
              printf 'previous_hash_file=/tmp/prev-hashes/dist-finanzas-bundle-hashes.txt\n' >> "$GITHUB_OUTPUT"
              echo "‚úÖ Previous hash file found at /tmp/prev-hashes/dist-finanzas-bundle-hashes.txt"
            else
              echo "‚ÑπÔ∏è  Previous run had no dist-finanzas-bundle-hashes.txt artifact."
              printf 'previous_run_found=false\n' >> "$GITHUB_OUTPUT"
            fi
          else
            echo "‚ÑπÔ∏è  gh run download failed (likely permission issue). Skipping previous-run hash comparison."
            echo "----- gh run download stderr -----"
            cat /tmp/gh_run_download_err.log || true
            printf 'previous_run_found=false\n' >> "$GITHUB_OUTPUT"
          fi

      - name: Compare bundle hashes with previous run
        if: steps.prev_run.outputs.previous_run_found == 'true'
        run: |
          set -euo pipefail
          PREV_FILE="${{ steps.prev_run.outputs.previous_hash_file }}"
          echo "üîç Comparing current bundle hashes with: $PREV_FILE"
          if diff -u "$PREV_FILE" dist-finanzas-bundle-hashes.txt; then
            echo "‚ÑπÔ∏è  Bundle hashes match previous successful run."
          else
            echo "‚ÑπÔ∏è  Bundle hashes differ from previous run (expected when Finanzas UI changed)."
          fi

      - name: Detect Finanzas source changes
        id: finz_changed
        run: bash scripts/detect-finz-changes.sh "${{ github.event.before || '' }}"

      - name: Guard - Bundle hash vs source changes consistency
        if: steps.prev_run.outputs.previous_run_found == 'true'
        run: bash scripts/guard-bundle-vs-source.sh "${{ steps.prev_run.outputs.previous_hash_file }}" "${{ steps.finz_changed.outputs.finz_changed }}"

      - name: Verify API URL embedded in Finanzas bundle
        env:
          VITE_API_BASE_URL: ${{ env.VITE_API_BASE_URL }}
        run: |
          set -euo pipefail

          VITE_API_BASE_URL="$(printf '%s' "$VITE_API_BASE_URL" | tr -d '\r\n')"
          VITE_API_BASE_URL="${VITE_API_BASE_URL%/}"

          DIST="dist-finanzas"
          echo "üîç Searching for VITE_API_BASE_URL in build artifacts..."

          if ! grep -R --binary-files=text -F "$VITE_API_BASE_URL" "$DIST" >/dev/null; then
            echo "‚ùå CRITICAL: VITE_API_BASE_URL ($VITE_API_BASE_URL) not found in $DIST"
            echo "   This means the API URL was not injected during build"
            echo ""
            echo "üîß Troubleshooting:"
            echo "   1. Check that VITE_API_BASE_URL was set during build"
            echo "   2. Verify vite.config.ts is properly injecting the value"
            echo "   3. Review build logs for Vite configuration errors"
            exit 1
          fi

          echo "‚úÖ VITE_API_BASE_URL found in Finanzas bundle"
          echo "üìã Sample occurrences:"
          grep -R --binary-files=text -F "$VITE_API_BASE_URL" "$DIST" | head -3 || true

      # Detect which credential method is available (must run in run: so we can read secrets)
      - name: Detect AWS credential method
        id: aws_creds
        shell: bash
        run: |
          set -euo pipefail
          echo "Detecting available AWS credential configuration..."
          # default outputs
          echo "oidc=false" >> "$GITHUB_OUTPUT"
          echo "static=false" >> "$GITHUB_OUTPUT"

          if [ -n "${{ secrets.OIDC_AWS_ROLE_ARN }}" ]; then
            echo "oidc=true" >> "$GITHUB_OUTPUT"
            echo "Detected OIDC_AWS_ROLE_ARN"
          fi

          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "static=true" >> "$GITHUB_OUTPUT"
            echo "Detected static AWS credentials"
          fi

      # Configure AWS via OIDC (preferred) ‚Äî note aws-region explicitly provided
      - name: Configure AWS credentials (OIDC)
        if: ${{ steps.aws_creds.outputs.oidc == 'true' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.OIDC_AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: preflight-${{ github.run_id }}

      # Configure AWS via static credentials as fallback (only if OIDC is not used)
      - name: Configure AWS credentials (static fallback)
        if: ${{ steps.aws_creds.outputs.static == 'true' && steps.aws_creds.outputs.oidc == 'false' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Guard: ensure AWS credentials are usable
      - name: Guard - ensure AWS creds configured
        shell: bash
        run: |
          set -euo pipefail
          echo "Checking AWS credentials are configured..."
          if ! aws sts get-caller-identity --region "${AWS_REGION}" >/tmp/aws_identity.json 2>/tmp/aws_sts_err.log; then
            echo "‚ùå AWS credentials are not configured or insufficient. Please provide either:"
            echo "   - secrets.OIDC_AWS_ROLE_ARN (preferred) with GitHub OIDC trust configured in AWS"
            echo "   - OR secrets.AWS_ACCESS_KEY_ID and secrets.AWS_SECRET_ACCESS_KEY"
            echo ""
            echo "Debug: detection step outputs:"
            echo "  oidc=${{ steps.aws_creds.outputs.oidc }} ; static=${{ steps.aws_creds.outputs.static }}"
            echo "----- STS error -----"
            cat /tmp/aws_sts_err.log || true
            exit 1
          fi
          echo "‚úÖ AWS credentials are configured. Caller identity:"
          jq -r '.Arn // .Account' /tmp/aws_identity.json || cat /tmp/aws_identity.json || true


      - name: Guard - S3 buckets and CloudFront exist
        run: |
          set -euo pipefail
          aws s3api head-bucket --bucket "${FINANZAS_BUCKET_NAME}" >/dev/null || { echo "‚ùå Missing Finanzas bucket ${FINANZAS_BUCKET_NAME}"; exit 1; }
          aws cloudfront get-distribution --id "${CLOUDFRONT_DIST_ID}" >/dev/null || { echo "‚ùå Missing CloudFront distribution ${CLOUDFRONT_DIST_ID}"; exit 1; }
          echo "‚úÖ Buckets & CloudFront found"

      - name: Guard - API endpoint present (VITE_API_BASE_URL)
        run: |
          set -euo pipefail
          : ${VITE_API_BASE_URL:?VITE_API_BASE_URL missing}
          BASE="${VITE_API_BASE_URL%/}"
          HOST_ID=$(echo "$BASE" | awk -F'[/.]' '{print $3}')
          : ${EXPECTED_API_ID:?EXPECTED_API_ID missing}
          if [ "$HOST_ID" != "$EXPECTED_API_ID" ]; then
            echo "‚ùå Expected API id ${EXPECTED_API_ID}, got ${HOST_ID}"; exit 1;
          fi
          CODE=$(curl -sS -o /dev/null -w '%{http_code}' "$BASE/health" || true)
          if [ "$CODE" != "200" ]; then
            echo "‚ùå /health returned $CODE ‚Äî check stage deployment"; exit 1;
          fi
          echo "‚úÖ API endpoint ID and /health verified: $BASE"

      - name: Guard - Finanzas build artifacts
        run: |
          set -euo pipefail
          if grep -R -nE 'src="/assets/|href="/assets/' dist-finanzas/index.html; then
            echo "‚ùå dist-finanzas/index.html points to /assets/* (missing base '/finanzas/')"; exit 1;
          fi
          if [ ! -f dist-finanzas/auth/callback.html ]; then
            echo "‚ùå Missing auth callback asset at dist-finanzas/auth/callback.html (expected from public/auth/callback.html)"
            exit 1
          fi
          if [ -f dist-finanzas/finanzas/auth/callback.html ]; then
            echo "‚ùå Unexpected nested callback found at dist-finanzas/finanzas/auth/callback.html"
            echo "   This would publish to /finanzas/finanzas/auth/callback.html and break the Hosted UI redirect"
            exit 1
          fi
          if grep -R -i 'github\.dev\|codespaces' dist-finanzas/ 2>/dev/null; then
            echo "‚ùå Build contains github.dev/codespaces references"; exit 1;
          fi
          if find dist-finanzas -name "aws-exports.js" -o -name "aws-exports.ts" | grep -q .; then
            echo "‚ùå CRITICAL: aws-exports.js found in Finanzas build!";
            echo "   aws-exports.js is a PMO/Amplify concern and should NOT be in Finanzas";
            exit 1;
          fi
          echo "‚úÖ Finanzas build artifacts look good"

      - name: Upload Finanzas Portal to S3 (/finanzas prefix)
        run: |
          aws s3 sync dist-finanzas/ "s3://${FINANZAS_BUCKET_NAME}/finanzas/" \
            --exclude '*.map' \
            --exclude 'docs/*' \
            --exclude 'test-helper.html' \
            --delete
          echo "‚úÖ Finanzas uploaded to s3://${FINANZAS_BUCKET_NAME}/finanzas/"

      # ---- CI Guard 3: S3 post-sync verification (post-upload) ----
      - name: Verify S3 sync and index.html asset references
        shell: bash
        env:
          FINANZAS_BUCKET_NAME: ${{ env.FINANZAS_BUCKET_NAME }}
        run: |
          set -euo pipefail

          # Collect local assets (full local path)
          mapfile -t LOC_ASSETS < <(find dist-finanzas/assets -type f \( -name 'index-*.js' -o -name 'index-*.css' \) 2>/dev/null || true)

          if [ ${#LOC_ASSETS[@]} -eq 0 ]; then
            echo "‚ùå No local assets found in dist-finanzas/assets; aborting verification"
            exit 1
          fi

          echo "üîç Verifying local assets are uploaded to S3 under finanzas/assets/ ..."
          MISSING=0
          for lf in "${LOC_ASSETS[@]}"; do
            base="$(basename "$lf")"
            s3key="finanzas/assets/${base}"
            if ! aws s3api head-object --bucket "${FINANZAS_BUCKET_NAME}" --key "$s3key" >/dev/null 2>&1; then
              echo "‚ùå Asset missing in S3: ${s3key}"
              MISSING=1
            else
              echo "‚úÖ Found in S3: ${s3key}"
            fi
          done

          if [ "$MISSING" -ne 0 ]; then
            echo "‚ùå One or more assets were not found in S3 after sync. Aborting."
            echo "----- S3 assets listing (finanzas/assets/) -----"
            aws s3 ls "s3://${FINANZAS_BUCKET_NAME}/finanzas/assets/" || true
            exit 1
          fi

          # Now verify the index.html references are present in S3
          INDEX="dist-finanzas/index.html"
          if [ ! -f "$INDEX" ]; then
            echo "‚ùå dist-finanzas/index.html missing"; exit 1;
          fi

          # Extract referenced assets like: assets/index-<fingerprint>.js
          # Accept alphanumeric + underscore + hyphen + dot in fingerprint
          grep -oE 'assets/index-[A-Za-z0-9._-]+\.(js|css)' "$INDEX" | sort -u > /tmp/local-references.txt || true

          if [ ! -s /tmp/local-references.txt ]; then
            echo "‚ùå No asset references found in $INDEX with the expected pattern."
            echo "Index snippet (first 200 lines):"
            head -n 200 "$INDEX" || true
            echo "----- End index snippet -----"
            echo "If your bundles use nonstandard names, adjust the regex 'assets/index-[A-Za-z0-9._-]+\\.(js|css)'."
            exit 1
          fi

          MISSREF=0
          echo "üîç Checking referenced assets in index.html exist in S3..."
          while read -r asset; do
            # asset is like "assets/index-abc123.js"
            s3key="finanzas/${asset}"   # keep the 'assets/' directory in the key
            if ! aws s3api head-object --bucket "${FINANZAS_BUCKET_NAME}" --key "$s3key" >/dev/null 2>&1; then
              echo "‚ùå Referenced asset NOT in S3: ${s3key}"
              MISSREF=1
            else
              echo "‚úÖ Referenced asset exists: ${s3key}"
            fi
          done < /tmp/local-references.txt

          if [ "$MISSREF" -ne 0 ]; then
            echo "‚ùå index.html references not found in S3 ‚Äî possible S3 sync path mismatch or deploy race."
            echo "----- S3 assets listing (finanzas/assets/) -----"
            aws s3 ls "s3://${FINANZAS_BUCKET_NAME}/finanzas/assets/" || true
            echo "----- index.html referenced assets -----"
            cat /tmp/local-references.txt || true
            exit 1
          fi

          echo "‚úÖ S3 verification complete"


      - name: Verify Finanzas S3 manifest matches local build
        run: |
          set -euo pipefail

          # Compare only the SPA assets we actually sync (exclude source maps, legacy docx, and docs/ bundles managed elsewhere)
          find dist-finanzas -type f \
            ! -name '*.map' \
            ! -name '*.docx' \
            ! -path 'dist-finanzas/docs/*' \
            -print \
            | sed 's|^dist-finanzas/||' \
            | sort > /tmp/local-finanzas-manifest.txt

          aws s3api list-objects-v2 \
            --bucket "${FINANZAS_BUCKET_NAME}" \
            --prefix "finanzas/" \
            --output json \
            | jq -r '.Contents[]?.Key
              | sub("^finanzas/"; "")
              | select(. | endswith(".map") | not)
              | select(. | endswith(".docx") | not)
              | select(. | startswith("docs/") | not)
            ' \
            | sort > /tmp/s3-finanzas-manifest.txt

          echo "üîç Comparing local vs S3 manifests (excluding .map/.docx files and docs/ prefix)..."
          if ! diff -u /tmp/local-finanzas-manifest.txt /tmp/s3-finanzas-manifest.txt; then
            echo "‚ùå Finanzas S3 manifest mismatch ‚Äî bucket drift detected"
            echo "   Ensure sync completed successfully and CloudFront invalidation is executed"
            exit 1
          fi

          echo "‚úÖ Finanzas S3 manifest matches local build"

      - name: Verify auth callback in S3
        run: |
          set -euo pipefail
          if ! aws s3api head-object --bucket "${FINANZAS_BUCKET_NAME}" --key "finanzas/auth/callback.html" >/dev/null 2>&1; then
            echo "‚ùå auth/callback.html missing in S3 at finanzas/auth/callback.html"
            echo "   Ensure public/auth/callback.html exists and dist-finanzas/auth/callback.html is produced by the build"
            exit 1
          fi
          echo "‚úÖ auth/callback.html present in S3 at finanzas/auth/callback.html"

      - name: Verify deployment metadata in S3
        run: |
          set -euo pipefail

          TMP_FILE=$(mktemp)
          aws s3 cp "s3://${FINANZAS_BUCKET_NAME}/finanzas/deployment-meta.json" "$TMP_FILE" >/dev/null
          DEPLOY_SHA=$(jq -r '.sha // empty' "$TMP_FILE")

          if [ -z "$DEPLOY_SHA" ]; then
            echo "‚ùå deployment-meta.json missing sha field"
            cat "$TMP_FILE"
            exit 1
          fi

          if [ "$DEPLOY_SHA" != "${GITHUB_SHA}" ]; then
            echo "‚ùå deployment-meta.json sha ($DEPLOY_SHA) does not match current commit ${GITHUB_SHA}"
            exit 1
          fi

          echo "‚úÖ deployment-meta.json in S3 matches current commit ${GITHUB_SHA}"

      - name: Guard - Verify CloudFront /finanzas/* Behavior (CRITICAL)
        run: |
          set -euo pipefail
          BEHAVIOR_COUNT=$(aws cloudfront get-distribution-config \
            --id "${CLOUDFRONT_DIST_ID}" \
            --query 'DistributionConfig.CacheBehaviors.Items[?PathPattern==`/finanzas/*`] | length(@)' \
            --output text)
          if [ "$BEHAVIOR_COUNT" != "1" ]; then
            echo "‚ùå CRITICAL: /finanzas/* behavior missing in CloudFront ${CLOUDFRONT_DIST_ID}"; exit 1;
          fi
          echo "‚úÖ /finanzas/* behavior configured"

      - name: Invalidate CloudFront (all + Finanzas SPA)
        run: |
          set -euo pipefail
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "${CLOUDFRONT_DIST_ID}" \
            --paths '/*' '/finanzas/*' '/finanzas/index.html' \
            --query 'Invalidation.Id' --output text)
          echo "‚úÖ Invalidation queued: $INVALIDATION_ID"

      - name: Verify CloudFront serves latest deployment metadata
        run: |
          set -euo pipefail

          DOMAIN="${CF_DOMAIN}"
          if [ -z "$DOMAIN" ]; then
            DOMAIN=$(aws cloudfront get-distribution --id "$CLOUDFRONT_DIST_ID" --query 'Distribution.DomainName' --output text)
          fi

          URL="https://${DOMAIN}/finanzas/deployment-meta.json"
          echo "üîç Waiting for CloudFront to serve ${URL} with sha ${GITHUB_SHA}"

          ATTEMPTS=12
          SLEEP_SECONDS=10

          for ((i=1; i<=ATTEMPTS; i++)); do
            RESPONSE=$(curl -sS --fail "$URL" || true)
            SHA=$(printf '%s' "$RESPONSE" | jq -r '.sha // empty' 2>/dev/null || true)

            if [ "$SHA" = "${GITHUB_SHA}" ]; then
              echo "‚úÖ CloudFront is serving the latest deployment metadata (attempt $i)"
              exit 0
            fi

            echo "‚è≥ Attempt $i/${ATTEMPTS}: sha='$SHA' (wanted ${GITHUB_SHA})"
            sleep "$SLEEP_SECONDS"
          done

          echo "‚ùå CloudFront did not serve the latest deployment metadata within $((ATTEMPTS * SLEEP_SECONDS)) seconds"
          echo "    URL: $URL"
          exit 1

      - name: UI Smoke (Finanzas /finanzas/)
        run: |
          set -euo pipefail
          DOMAIN="${CF_DOMAIN}"
          if [ -z "$DOMAIN" ]; then
            DOMAIN=$(aws cloudfront get-distribution --id "$CLOUDFRONT_DIST_ID" --query 'Distribution.DomainName' --output text)
          fi
          FINZ="https://${DOMAIN}/finanzas/"
          STATUS=$(curl -sS -o /dev/null -w '%{http_code}' "$FINZ")
          echo "Finanzas /finanzas/ status: $STATUS"
          if [ "$STATUS" = "200" ]; then
            HTML_SNIPPET=$(curl -sS "$FINZ" | head -n 40)
            echo "$HTML_SNIPPET" | grep -q "/finanzas/assets/" || { echo "‚ö†Ô∏è HTML missing /finanzas/assets references"; }
          else
            echo "‚ùå Finanzas portal not accessible (HTTP $STATUS)"; exit 1;
          fi

      - name: Deep-route SPA smoke test
        run: |
          set -euo pipefail
          DOMAIN="${CF_DOMAIN}"
          if [ -z "$DOMAIN" ]; then
            DOMAIN=$(aws cloudfront get-distribution --id "$CLOUDFRONT_DIST_ID" --query 'Distribution.DomainName' --output text)
          fi

          DEEP_ROUTE="https://${DOMAIN}/finanzas/sdmt/cost/forecast"
          echo "Testing deep SPA route: $DEEP_ROUTE"

          STATUS=$(curl -sS -o /tmp/deep_route.html -w '%{http_code}' "$DEEP_ROUTE" 2>/dev/null || echo "000")
          echo "Deep route status: $STATUS"

          if [ "$STATUS" != "200" ]; then
            echo "‚ùå Deep-route test failed (HTTP $STATUS)"
            echo "   SPA routing may not be configured correctly"
            exit 1
          fi

          if [ -f /tmp/deep_route.html ]; then
            if grep -q "/finanzas/assets/" /tmp/deep_route.html; then
              echo "‚úÖ Deep-route returns valid SPA content (found /finanzas/assets/)"
            else
              echo "‚ùå Deep-route response missing /finanzas/assets/ references"
              echo "   This may indicate CloudFront is not handling SPA routing correctly"
              exit 1
            fi
          fi

          echo "‚úÖ Deep-route SPA smoke test passed"

      - name: API Smokes (public /health, /catalog/rubros)
        run: |
          set -euo pipefail
          : ${VITE_API_BASE_URL:?VITE_API_BASE_URL missing}
          BASE="${VITE_API_BASE_URL%/}"
          echo "API base: $BASE"
          CODE=$(curl -sS -o /dev/null -w '%{http_code}' "$BASE/health" || true)
          [ "$CODE" = "200" ] || { echo "‚ùå /health returned $CODE"; exit 1; }
          LEN=$(curl -sS "$BASE/catalog/rubros" | jq '.data | length' || echo "0")
          echo "Catalog items: $LEN"
          [ "$LEN" != "0" ] || echo "‚ö†Ô∏è catalog/rubros length is 0 (seed missing?)"

      - name: Post-Deployment Comprehensive Verification
        run: |
          set -euo pipefail
          export CLOUDFRONT_DOMAIN="${CF_DOMAIN}"
          export VITE_API_BASE_URL="${VITE_API_BASE_URL}"
          export S3_BUCKET="${FINANZAS_BUCKET_NAME}"

          echo "üîç Running comprehensive post-deployment verification..."
          bash scripts/post-deploy-verify.sh || {
            echo "‚ùå Post-deployment verification failed"
            echo "   This indicates the deployment may not be functioning correctly"
            echo "   Review the errors above before proceeding"
            exit 1
          }

      - name: Summary & Evidence Pack
        if: always()
        run: |
          set -eo pipefail
          DOMAIN="${CF_DOMAIN}"
          if [ -z "$DOMAIN" ]; then
            DOMAIN=$(aws cloudfront get-distribution --id "$CLOUDFRONT_DIST_ID" --query 'Distribution.DomainName' --output text)
          fi
          export SUMMARY_DOMAIN="$DOMAIN"
          export SUMMARY_API="${VITE_API_BASE_URL:-N/A}"
          bash scripts/append-finanzas-summary.sh
